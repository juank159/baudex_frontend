import 'package:flutter/services.dart';
import 'package:image/image.dart' as img;

// lib/features/invoices/presentation/controllers/thermal_printer_controller.dart
import 'dart:io';
import 'dart:typed_data';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:esc_pos_utils_plus/esc_pos_utils_plus.dart';
import 'package:esc_pos_printer_plus/esc_pos_printer_plus.dart';
import 'package:intl/intl.dart';
import '../../domain/entities/invoice.dart';

// ==================== CONFIGURACI√ìN ESPEC√çFICA SAT Q22UE ====================

class SATQ22UEConfig {
  static const String defaultNetworkIP = '192.168.1.181';
  static const int defaultNetworkPort = 9100;
  static const PaperSize paperSize = PaperSize.mm80;

  // Comandos espec√≠ficos para SAT Q22UE
  static const List<int> initializeCommands = [
    0x1B, 0x40, // ESC @ (Inicializar impresora)
    0x1B, 0x74, 0x06, // ESC t (Seleccionar juego de caracteres)
  ];

  static const List<int> cutCommands = [
    0x1D, 0x56, 0x41, 0x03, // Corte parcial
  ];

  static const List<int> openDrawerCommands = [
    0x1B, 0x70, 0x00, 0x19, 0xFF, // Abrir caj√≥n
  ];
}

// ==================== MODELOS DE DATOS ====================

class NetworkPrinterInfo {
  final String ip;
  final int port;
  final bool isConnected;

  const NetworkPrinterInfo({
    required this.ip,
    required this.port,
    this.isConnected = false,
  });

  NetworkPrinterInfo copyWith({String? ip, int? port, bool? isConnected}) {
    return NetworkPrinterInfo(
      ip: ip ?? this.ip,
      port: port ?? this.port,
      isConnected: isConnected ?? this.isConnected,
    );
  }
}

class PrintJob {
  final String invoiceNumber;
  final DateTime timestamp;
  final bool success;
  final String? error;
  final String method;

  const PrintJob({
    required this.invoiceNumber,
    required this.timestamp,
    required this.success,
    this.error,
    required this.method,
  });
}

// ==================== CONTROLADOR PRINCIPAL ====================

class ThermalPrinterController extends GetxController {
  // ==================== OBSERVABLES ====================

  final _isConnected = false.obs;
  final _isPrinting = false.obs;
  final _lastError = Rxn<String>();
  final _printHistory = <PrintJob>[].obs;

  // Estado de red vs USB
  final _preferUSB = true.obs; // Desktop prefiere USB
  final _networkPrinters = <NetworkPrinterInfo>[].obs;

  final format = NumberFormat(
    '#,###',
    'es_CO',
  ); // es_CO usa puntos como separador

  // ==================== GETTERS ====================

  bool get isConnected => _isConnected.value;
  bool get isPrinting => _isPrinting.value;
  String? get lastError => _lastError.value;
  List<PrintJob> get printHistory => _printHistory;
  bool get preferUSB => _preferUSB.value;
  List<NetworkPrinterInfo> get networkPrinters => _networkPrinters;

  // ==================== LIFECYCLE ====================

  @override
  void onInit() {
    super.onInit();
    print('üñ®Ô∏è ThermalPrinterController: Inicializando...');
    _initializePrinter();
  }

  @override
  void onClose() {
    print('üîö ThermalPrinterController: Cerrando conexiones...');
    _closeAllConnections();
    super.onClose();
  }

  // ==================== INITIALIZATION ====================

  Future<void> _initializePrinter() async {
    try {
      // Determinar estrategia seg√∫n plataforma
      if (kIsWeb || GetPlatform.isMobile) {
        _preferUSB.value = false; // M√≥vil/Web solo red
        print('üì± Plataforma m√≥vil/web detectada - Solo impresi√≥n por red');
      } else {
        _preferUSB.value = true; // Desktop prefiere USB
        print('üíª Plataforma desktop detectada - Preferencia USB');
      }

      await _discoverNetworkPrinters();

      print('‚úÖ ThermalPrinterController inicializado');
    } catch (e) {
      print('‚ùå Error inicializando impresora t√©rmica: $e');
      _lastError.value = e.toString();
    }
  }

  // ==================== UTILIDADES HELPER ====================

  String _getPlatformName() {
    if (kIsWeb) return 'Web';
    if (GetPlatform.isMobile) return 'Mobile';
    if (GetPlatform.isDesktop) return 'Desktop';
    return 'Unknown';
  }
  // ==================== DISCOVERY ====================

  Future<void> _discoverNetworkPrinters() async {
    try {
      print('üîç Buscando impresoras en red...');

      // Limpiar lista anterior
      _networkPrinters.clear();

      // Probar IP conocida primero
      final isAvailable = await _testNetworkPrinter(
        SATQ22UEConfig.defaultNetworkIP,
        SATQ22UEConfig.defaultNetworkPort,
      );

      if (isAvailable) {
        _networkPrinters.add(
          const NetworkPrinterInfo(
            ip: SATQ22UEConfig.defaultNetworkIP,
            port: SATQ22UEConfig.defaultNetworkPort,
            isConnected: false,
          ),
        );
        print('‚úÖ Impresora SAT encontrada en IP conocida');
      }
    } catch (e) {
      print('‚ùå Error en descubrimiento de red: $e');
      _lastError.value = 'Error buscando impresoras: $e';
    }
  }

  Future<bool> _testNetworkPrinter(String ip, int port) async {
    try {
      final profile = await CapabilityProfile.load();
      final printer = NetworkPrinter(SATQ22UEConfig.paperSize, profile);

      // Intentar conexi√≥n con timeout corto
      final result = await printer
          .connect(ip, port: port)
          .timeout(const Duration(seconds: 3));

      if (result == PosPrintResult.success) {
        printer.disconnect(); // Sin await - void return
        print('‚úÖ Impresora encontrada en $ip:$port');
        return true;
      }

      printer.disconnect(); // Sin await - void return
      return false;
    } catch (e) {
      print('‚ö†Ô∏è No hay impresora en $ip:$port');
      return false;
    }
  }

  Future<void> refreshPrinters() async {
    print('üîÑ Refrescando lista de impresoras...');
    await _discoverNetworkPrinters();
  }
  // ==================== IMPRESI√ìN PRINCIPAL ====================

  Future<bool> printInvoice(Invoice invoice) async {
    if (_isPrinting.value) {
      _showError(
        'Impresi√≥n en curso',
        'Ya hay una impresi√≥n en curso, espere a que termine',
      );
      return false;
    }

    try {
      _isPrinting.value = true;
      _lastError.value = null;

      print('üñ®Ô∏è === INICIANDO IMPRESI√ìN T√âRMICA ===');
      print('   - Factura: ${invoice.number}');
      print('   - Plataforma: ${_getPlatformName()}');
      print('   - Preferir USB: $_preferUSB');

      bool success = false;

      // Estrategia de impresi√≥n seg√∫n plataforma
      if (!kIsWeb && !GetPlatform.isMobile && _preferUSB.value) {
        print('üíª Intentando impresi√≥n USB primero...');
        success = await _printViaUSB(invoice);

        if (!success) {
          print('üîÑ USB fall√≥, intentando red...');
          success = await _printViaNetwork(invoice);
        }
      } else {
        print('üì± Imprimiendo solo por red...');
        success = await _printViaNetwork(invoice);
      }

      if (success) {
        _addToPrintHistory(invoice, true);
        _showSuccess('Factura impresa exitosamente');
        print('‚úÖ Impresi√≥n completada exitosamente');
      } else {
        _addToPrintHistory(invoice, false, _lastError.value);
        _showError(
          'Error al imprimir',
          _lastError.value ?? "Error desconocido",
        );
        print('‚ùå Impresi√≥n fall√≥');
      }

      return success;
    } catch (e) {
      print('üí• Error inesperado en impresi√≥n: $e');
      _lastError.value = e.toString();
      _addToPrintHistory(invoice, false, e.toString());
      _showError('Error inesperado', e.toString());
      return false;
    } finally {
      _isPrinting.value = false;
    }
  }
  // ==================== IMPRESI√ìN USB ====================

  Future<bool> _printViaUSB(Invoice invoice) async {
    try {
      print('üîå Intentando impresi√≥n USB...');

      // TODO: Implementar impresi√≥n USB directa
      // Esto requiere librer√≠as espec√≠ficas del SO o comandos del sistema

      if (Platform.isWindows) {
        return await _printUSBWindows(invoice);
      } else if (Platform.isLinux) {
        return await _printUSBLinux(invoice);
      } else if (Platform.isMacOS) {
        return await _printUSBMacOS(invoice);
      }

      print('‚ö†Ô∏è Impresi√≥n USB no soportada en esta plataforma');
      return false;
    } catch (e) {
      print('‚ùå Error en impresi√≥n USB: $e');
      _lastError.value = 'USB: $e';
      return false;
    }
  }

  Future<bool> _printUSBWindows(Invoice invoice) async {
    // TODO: Implementar usando comandos Windows o librer√≠as espec√≠ficas
    print('ü™ü Impresi√≥n USB Windows no implementada a√∫n');
    return false;
  }

  Future<bool> _printUSBLinux(Invoice invoice) async {
    // TODO: Implementar usando /dev/usb/lp* o cups
    print('üêß Impresi√≥n USB Linux no implementada a√∫n');
    return false;
  }

  Future<bool> _printUSBMacOS(Invoice invoice) async {
    // TODO: Implementar usando cups o librer√≠as espec√≠ficas
    print('üçé Impresi√≥n USB macOS no implementada a√∫n');
    return false;
  }
  // ==================== IMPRESI√ìN RED ====================

  Future<bool> _printViaNetwork(Invoice invoice) async {
    try {
      print('üåê Intentando impresi√≥n por red...');

      if (_networkPrinters.isEmpty) {
        await _discoverNetworkPrinters();
      }

      if (_networkPrinters.isEmpty) {
        _lastError.value = 'No se encontraron impresoras en red';
        return false;
      }

      // Usar la primera impresora disponible
      final printerInfo = _networkPrinters.first;
      return await _sendToPrinter(printerInfo, invoice);
    } catch (e) {
      print('‚ùå Error en impresi√≥n por red: $e');
      _lastError.value = 'Red: $e';
      return false;
    }
  }

  Future<bool> _sendToPrinter(
    NetworkPrinterInfo printerInfo,
    Invoice invoice,
  ) async {
    NetworkPrinter? printer;

    try {
      final profile = await CapabilityProfile.load();
      printer = NetworkPrinter(SATQ22UEConfig.paperSize, profile);

      print('üîó Conectando a ${printerInfo.ip}:${printerInfo.port}...');

      final result = await printer.connect(
        printerInfo.ip,
        port: printerInfo.port,
      );

      if (result != PosPrintResult.success) {
        _lastError.value = 'Error de conexi√≥n: ${result.msg}';
        return false;
      }

      _isConnected.value = true;
      print('‚úÖ Conectado a impresora SAT');

      // Generar contenido de impresi√≥n
      await _generatePrintContent(printer, invoice);

      // Enviar comandos de corte
      printer.rawBytes(Uint8List.fromList(SATQ22UEConfig.cutCommands));

      print('üìÑ Contenido enviado a impresora');
      return true;
    } catch (e) {
      print('‚ùå Error enviando a impresora: $e');
      _lastError.value = e.toString();
      return false;
    } finally {
      if (printer != null) {
        printer.disconnect(); // Sin await - void return
        _isConnected.value = false;
        print('üîå Desconectado de impresora');
      }
    }
  }
  // ==================== GENERACI√ìN DE CONTENIDO ====================

  Future<void> _generatePrintContent(
    NetworkPrinter printer,
    Invoice invoice,
  ) async {
    try {
      // Inicializar impresora con comandos espec√≠ficos SAT
      printer.rawBytes(Uint8List.fromList(SATQ22UEConfig.initializeCommands));

      // Header de empresa
      await _printBusinessHeader(printer);

      // Informaci√≥n de factura
      await _printInvoiceInfo(printer, invoice);

      // Informaci√≥n del cliente
      await _printCustomerInfo(printer, invoice);

      // Items
      await _printItems(printer, invoice);

      // Totales
      await _printTotals(printer, invoice);

      // Footer
      await _printFooter(printer, invoice);

      // Espaciado final
      printer.feed(3);
    } catch (e) {
      print('‚ùå Error generando contenido: $e');
      throw Exception('Error en generaci√≥n de contenido: $e');
    }
  }

  Future<img.Image?> _loadLogoImage() async {
    try {
      print('üñºÔ∏è Cargando logo desde assets...');

      // Cargar imagen desde assets
      final ByteData data = await rootBundle.load(
        'assets/images/LOGO_GRANADA.png',
      );
      final Uint8List bytes = data.buffer.asUint8List();

      // Decodificar imagen
      final img.Image? originalImage = img.decodeImage(bytes);

      if (originalImage == null) {
        print('‚ùå No se pudo decodificar la imagen');
        return null;
      }

      // Redimensionar para impresora t√©rmica (m√°ximo 384 p√≠xeles de ancho para 80mm)
      final img.Image resizedImage = img.copyResize(
        originalImage,
        width: 480, // Ancho m√°ximo recomendado
        height: -1, // Altura proporcional
        interpolation:
            img.Interpolation.nearest, // Mejor para impresoras t√©rmicas
      );

      // Convertir a escala de grises y aumentar contraste
      final img.Image processedImage = _processImageForThermal(resizedImage);

      print(
        '‚úÖ Logo procesado: ${processedImage.width}x${processedImage.height}',
      );
      return processedImage;
    } catch (e) {
      print('‚ùå Error cargando logo: $e');
      return null;
    }
  }

  /// Procesar imagen para impresi√≥n t√©rmica √≥ptima
  img.Image _processImageForThermal(img.Image image) {
    // Convertir a escala de grises
    final img.Image grayImage = img.grayscale(image);

    // Aumentar contraste para mejor definici√≥n en impresora t√©rmica
    final img.Image contrastedImage = img.contrast(grayImage, contrast: 250);

    // Aplicar dithering para mejor calidad en blanco y negro
    final img.Image ditheredImage = img.monochrome(contrastedImage);

    return ditheredImage;
  }

  /// Verificar si hay logo disponible
  Future<bool> _hasLogoAvailable() async {
    try {
      await rootBundle.load('assets/images/LOGO_GRANADA.png');
      return true;
    } catch (e) {
      print('‚ö†Ô∏è Logo no disponible: $e');
      return false;
    }
  }

  Future<void> _printBusinessHeader(NetworkPrinter printer) async {
    try {
      // Intentar imprimir logo
      final bool hasLogo = await _hasLogoAvailable();

      if (hasLogo) {
        print('üñºÔ∏è Imprimiendo header con logo...');
        await _printBusinessHeaderWithImage(printer);
      } else {
        print('üìù Imprimiendo header sin logo...');
        await _printBusinessHeaderTextOnly(printer);
      }
    } catch (e) {
      print('‚ùå Error en header, usando versi√≥n de texto: $e');
      await _printBusinessHeaderTextOnly(printer);
    }
  }

  /// Header con imagen
  Future<void> _printBusinessHeaderWithImage(NetworkPrinter printer) async {
    try {
      // Cargar y procesar logo
      final img.Image? logo = await _loadLogoImage();

      if (logo != null) {
        // Imprimir logo centrado
        printer.image(logo, align: PosAlign.center);
      }
    } catch (e) {
      print('‚ùå Error imprimiendo logo: $e');
      // Fallback a versi√≥n de texto
      await _printBusinessHeaderTextOnly(printer);
      return;
    }
  }

  /// Header solo texto (versi√≥n original como fallback)
  Future<void> _printBusinessHeaderTextOnly(NetworkPrinter printer) async {
    // Logo/T√≠tulo centrado (versi√≥n original)
    printer.text(
      ' La Granada.',
      styles: const PosStyles(
        align: PosAlign.center,
        bold: true,
        height: PosTextSize.size2,
        width: PosTextSize.size2,
      ),
    );

    printer.text(
      'Ragonvalia, Norte de Santander',
      styles: const PosStyles(align: PosAlign.center),
    );

    printer.text(
      'Tel: +57 3167181910',
      styles: const PosStyles(align: PosAlign.center),
    );
  }

  void setImageQuality({
    int maxWidth = 800,
    bool useMonochrome = true,
    int contrast = 250,
  }) {
    // Estas configuraciones se pueden usar en _processImageForThermal
    print('‚öôÔ∏è Configuraci√≥n de imagen actualizada');
    print('   - Ancho m√°ximo: ${maxWidth}px');
    print('   - Monocromo: $useMonochrome');
    print('   - Contraste: $contrast');
  }

  /// Debug de imagen
  Future<void> debugImageInfo() async {
    try {
      final hasLogo = await _hasLogoAvailable();
      print('üîç === INFO DE IMAGEN ===');
      print('   - Logo disponible: $hasLogo');

      if (hasLogo) {
        final logo = await _loadLogoImage();
        if (logo != null) {
          print('   - Dimensiones: ${logo.width}x${logo.height}');
          print('   - Canales: ${logo.numChannels}');
        }
      }
    } catch (e) {
      print('‚ùå Error en debug de imagen: $e');
    }
  }

  Future<void> _printInvoiceInfo(
    NetworkPrinter printer,
    Invoice invoice,
  ) async {
    printer.text(
      'FACTURA DE VENTA',
      styles: const PosStyles(
        align: PosAlign.center,
        bold: true,
        height: PosTextSize.size1,
        width: PosTextSize.size1,
      ),
    );

    printer.feed(1);

    // N√∫mero de factura
    printer.row([
      PosColumn(text: 'No:', width: 4, styles: const PosStyles(bold: true)),
      PosColumn(
        text: invoice.number,
        width: 8,
        styles: const PosStyles(align: PosAlign.right),
      ),
    ]);

    // Fecha
    final now = DateTime.now();
    final dateStr =
        '${now.day}/${now.month}/${now.year} ${now.hour}:${now.minute.toString().padLeft(2, '0')}';
    printer.row([
      PosColumn(text: 'Fecha:', width: 4, styles: const PosStyles(bold: true)),
      PosColumn(
        text: dateStr,
        width: 8,
        styles: const PosStyles(align: PosAlign.right),
      ),
    ]);

    // M√©todo de pago
    printer.row([
      PosColumn(text: 'Pago:', width: 4, styles: const PosStyles(bold: true)),
      PosColumn(
        text: invoice.paymentMethodDisplayName,
        width: 8,
        styles: const PosStyles(align: PosAlign.right),
      ),
    ]);

    printer.hr();
  }

  Future<void> _printCustomerInfo(
    NetworkPrinter printer,
    Invoice invoice,
  ) async {
    printer.text('CLIENTE:', styles: const PosStyles(bold: true));

    printer.text(
      invoice.customerName,
      styles: const PosStyles(align: PosAlign.left),
    );

    if (invoice.customerEmail?.isNotEmpty == true) {
      printer.text(
        invoice.customerEmail!,
        styles: const PosStyles(align: PosAlign.left),
      );
    }

    printer.hr();
  }

  Future<void> _printItems(NetworkPrinter printer, Invoice invoice) async {
    // ‚úÖ ENCABEZADO DE TABLA PROFESIONAL
    printer.text(
      'ITEM      CANT.       V.UNIT            IVA              TOTAL',
      styles: PosStyles(
        align: PosAlign.left, // Alineaci√≥n centrada
        bold: true,
        fontType: PosFontType.fontB,
      ),
    );
    printer.hr(ch: '-', len: 40);

    // ‚úÖ CONTADOR DE ITEMS
    int itemNumber = 1;

    for (final item in invoice.items) {
      // ‚úÖ T√çTULO DEL PRODUCTO CON N√öMERO
      printer.text(
        '${itemNumber.toString().padLeft(2, '0')} - ${item.description.toUpperCase()}',
        styles: const PosStyles(bold: true, align: PosAlign.left),
      );

      // ‚úÖ L√çNEA DE DETALLES - CORREGIDA PARA SUMAR 12
      final quantity = item.quantity.toInt().toString();
      final unitPrice = item.unitPrice.toStringAsFixed(0);
      final discount =
          item.discountAmount > 0
              ? item.discountAmount.toStringAsFixed(0)
              : (item.discountPercentage > 0
                  ? '${item.discountPercentage.toInt()}%'
                  : '0');
      final total = item.quantity * item.unitPrice;
      final itemTotal = total.toStringAsFixed(0);

      // ‚úÖ FORMATEAR L√çNEA CON WIDTH CORRECTO (total = 12)
      printer.row([
        PosColumn(
          text: '',
          width: 2, // Cantidad
          styles: const PosStyles(align: PosAlign.center),
        ),
        PosColumn(
          text: quantity,
          width: 2, // Unidad
          styles: const PosStyles(align: PosAlign.left),
        ),
        PosColumn(
          text: '\$${format.format(item.unitPrice)}',
          width: 3, // ‚úÖ CAMBIADO de 4 a 3
          styles: const PosStyles(align: PosAlign.left),
        ),
        // PosColumn(
        //   text: discount,
        //   width: 2, // Descuento
        //   styles: const PosStyles(align: PosAlign.center),
        // ),
        PosColumn(
          text: '19',
          width: 1, // IVA
          styles: const PosStyles(align: PosAlign.right),
        ),
        PosColumn(
          //text: '\$${itemTotal}',
          text: '\$${itemTotal}',
          width: 4, // ‚úÖ CAMBIADO de 4 a 3
          styles: const PosStyles(align: PosAlign.right, bold: true),
        ),
      ]);
      // TOTAL: 2+1+3+2+1+3 = 12 ‚úÖ

      // ‚úÖ INFORMACI√ìN ADICIONAL (garant√≠a autom√°tica)
      if (item.notes != null && item.notes!.isNotEmpty) {
        printer.text(
          item.notes!,
          styles: const PosStyles(
            fontType: PosFontType.fontB,
            align: PosAlign.left,
          ),
        );
      } else {
        // Garant√≠a por defecto para ciertos productos
        if (item.description.toLowerCase().contains('impresora') ||
            item.description.toLowerCase().contains('equipo') ||
            item.description.toLowerCase().contains('dispositivo')) {
          printer.text(
            'GARANTIA DE 3 MESES POR DEFECTOS DE FABRICA',
            styles: const PosStyles(
              fontType: PosFontType.fontB,
              align: PosAlign.left,
            ),
          );
        }
      }

      //printer.feed(1);
      itemNumber++;
    }

    // ‚úÖ RESUMEN DE ITEMS
    printer.hr(ch: '-', len: 40);
    printer.text(
      'TOTAL ITEMS: ${invoice.items.length}',
      styles: const PosStyles(bold: true, align: PosAlign.left),
    );
    printer.feed(1);
  }

  // ‚úÖ TAMBI√âN CORREGIR _printTotals PARA EVITAR ERRORES:

  Future<void> _printTotals(NetworkPrinter printer, Invoice invoice) async {
    // ‚úÖ C√ÅLCULOS DETALLADOS
    final subtotalSinIva =
        invoice.subtotal / (1 + (invoice.taxPercentage / 100));
    final ivaCalculado = invoice.subtotal - subtotalSinIva;

    //   // ‚úÖ TOTALES DETALLADOS - WIDTH CORREGIDO (total = 12)
    //   printer.row([
    //     PosColumn(
    //       text: 'Subtotal:',
    //       width: 8, // ‚úÖ CORRECTO
    //       styles: const PosStyles(align: PosAlign.left, bold: true),
    //     ),
    //     PosColumn(
    //       text: '\$${subtotalSinIva.toStringAsFixed(1)}',
    //       width: 4, // ‚úÖ CORRECTO (8+4=12)
    //       styles: const PosStyles(align: PosAlign.right),
    //     ),
    //   ]);

    //   printer.row([
    //     PosColumn(
    //       text: 'IVA:',
    //       width: 8,
    //       styles: const PosStyles(align: PosAlign.left, bold: true),
    //     ),
    //     PosColumn(
    //       text: '\$${ivaCalculado.toStringAsFixed(1)}',
    //       width: 4,
    //       styles: const PosStyles(align: PosAlign.right),
    //     ),
    //   ]);

    //   // ‚úÖ TOTAL FINAL - WIDTH CORREGIDO
    printer.row([
      PosColumn(
        text: 'TOTAL A PAGAR:',
        width: 8,
        styles: const PosStyles(
          align: PosAlign.left,
          bold: true,
          height: PosTextSize.size2,
        ),
      ),
      PosColumn(
        text: ': \$${format.format(invoice.total)}',
        width: 4,
        styles: const PosStyles(
          align: PosAlign.right,
          bold: true,
          height: PosTextSize.size2,
        ),
      ),
    ]);
    printer.feed(1);
  }

  Future<void> _printFooter(NetworkPrinter printer, Invoice invoice) async {
    // printer.feed(1);

    // // Informaci√≥n adicional si hay
    if (invoice.notes?.isNotEmpty == true) {
      //printer.text('NOTAS:', styles: const PosStyles(bold: true));
      printer.text(
        invoice.notes!,
        styles: const PosStyles(align: PosAlign.left, bold: true),
      );
      printer.feed(1);
    }

    // Fecha y hora de impresi√≥n
    final now = DateTime.now();
    final timeStr =
        '${now.day}/${now.month}/${now.year} ${now.hour}:${now.minute.toString().padLeft(2, '0')}';

    printer.text(
      'Impreso: $timeStr',
      styles: const PosStyles(
        align: PosAlign.center,
        fontType: PosFontType.fontB,
      ),
    );
    // Mensaje de agradecimiento
    printer.text(
      '¬°Gracias por su compra!',
      styles: const PosStyles(align: PosAlign.center, bold: true),
    );
    printer.feed(1);
    printer.text(
      'Desarrollado, Impreso y Generado por Baudex',
      styles: const PosStyles(align: PosAlign.center),
    );
    printer.text(
      'Baudex es una marca registrada de Baudity',
      styles: const PosStyles(align: PosAlign.center),
    );
    printer.text(
      'Informacion: 3138888436',
      styles: const PosStyles(align: PosAlign.center),
    );
  }

  // ==================== GESTI√ìN DE HISTORIAL ====================

  void _addToPrintHistory(Invoice invoice, bool success, [String? error]) {
    final job = PrintJob(
      invoiceNumber: invoice.number,
      timestamp: DateTime.now(),
      success: success,
      error: error,
      method: _preferUSB.value ? 'USB' : 'Red',
    );

    _printHistory.insert(0, job);

    // Mantener solo los √∫ltimos 50 trabajos
    if (_printHistory.length > 50) {
      _printHistory.removeRange(50, _printHistory.length);
    }

    update();
  }

  void clearPrintHistory() {
    _printHistory.clear();
    update();
  }

  // ==================== UTILIDADES ====================

  Future<void> _closeAllConnections() async {
    try {
      _isConnected.value = false;
      _networkPrinters.clear();
      print('üîå Todas las conexiones cerradas');
    } catch (e) {
      print('‚ùå Error cerrando conexiones: $e');
    }
  }

  void setPreferUSB(bool prefer) {
    _preferUSB.value = prefer;
    print('‚öôÔ∏è Preferencia USB cambiada a: $prefer');
  }
  // ==================== MENSAJES ====================

  void _showError(String title, String message) {
    Get.snackbar(
      title,
      message,
      snackPosition: SnackPosition.TOP,
      backgroundColor: Colors.red.shade100,
      colorText: Colors.red.shade800,
      icon: const Icon(Icons.error, color: Colors.red),
      duration: const Duration(seconds: 4),
    );
  }

  void _showSuccess(String message) {
    Get.snackbar(
      'Impresi√≥n Exitosa',
      message,
      snackPosition: SnackPosition.TOP,
      backgroundColor: Colors.green.shade100,
      colorText: Colors.green.shade800,
      icon: const Icon(Icons.check_circle, color: Colors.green),
      duration: const Duration(seconds: 3),
    );
  }

  // ==================== DEBUG ====================

  void debugPrintStatus() {
    print('üîç === ESTADO IMPRESORA T√âRMICA ===');
    print('   - Conectado: $isConnected');
    print('   - Imprimiendo: $isPrinting');
    print('   - Preferir USB: $preferUSB');
    print('   - Impresoras red: ${networkPrinters.length}');
    print('   - √öltimo error: $lastError');
    print('   - Historial: ${printHistory.length} trabajos');
  }
}
