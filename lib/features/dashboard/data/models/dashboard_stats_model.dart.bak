// lib/features/dashboard/data/models/dashboard_stats_model.dart
import '../../domain/entities/dashboard_stats.dart';
import 'profitability_stats_model.dart';

class DashboardStatsModel extends DashboardStats {
  const DashboardStatsModel({
    required SalesStatsModel sales,
    required InvoiceStatsModel invoices,
    required ProductStatsModel products,
    required CustomerStatsModel customers,
    required ExpenseStatsModel expenses,
    required ProfitabilityStatsModel profitability,
    required List<PaymentMethodStats> paymentMethodsBreakdown,
    required IncomeTypeBreakdown incomeTypeBreakdown,
  }) : super(
         sales: sales,
         invoices: invoices,
         products: products,
         customers: customers,
         expenses: expenses,
         profitability: profitability,
         paymentMethodsBreakdown: paymentMethodsBreakdown,
         incomeTypeBreakdown: incomeTypeBreakdown,
       );

  factory DashboardStatsModel.fromJson(Map<String, dynamic> json) {
    // Mapear desde la estructura plana del backend a la estructura anidada del frontend
    return DashboardStatsModel(
      sales: SalesStatsModel(
        totalAmount:
            (json['totalRevenue'] ?? 0)
                .toDouble(), // ✅ CORREGIDO: usar totalRevenue
        totalSales: json['totalInvoices'] ?? 0,
        todaySales: (json['totalRevenue'] ?? 0).toDouble(), // Usar revenue real
        yesterdaySales: 0.0, // TODO: agregar al backend
        monthlySales:
            (json['totalRevenue'] ?? 0).toDouble(), // Usar revenue real
        yearSales: (json['totalRevenue'] ?? 0).toDouble(), // Usar revenue real
        todayGrowth:
            (json['revenueGrowth'] ?? 0).toDouble(), // Usar growth real
        monthlyGrowth: 0.0, // TODO: agregar al backend
      ),
      invoices: InvoiceStatsModel(
        totalInvoices: json['totalInvoices'] ?? 0,
        todayInvoices: 0, // TODO: agregar al backend
        pendingInvoices: json['pendingInvoices'] ?? 0,
        paidInvoices: json['paidInvoices'] ?? 0,
        averageInvoiceValue:
            json['totalInvoices'] > 0
                ? ((json['totalRevenue'] ?? 0).toDouble() /
                    json['totalInvoices'])
                : 0.0,
        todayGrowth: 0.0, // TODO: agregar al backend
      ),
      products: ProductStatsModel(
        totalProducts: json['totalProducts'] ?? 0,
        activeProducts: json['totalProducts'] ?? 0,
        lowStockProducts: json['lowStockProducts'] ?? 0,
        outOfStockProducts: json['outOfStockProducts'] ?? 0,
        totalInventoryValue: 0.0, // TODO: agregar al backend
        todayGrowth: 0, // TODO: agregar al backend
      ),
      customers: CustomerStatsModel(
        totalCustomers: json['totalCustomers'] ?? 0,
        activeCustomers: json['activeCustomers'] ?? 0,
        newCustomersToday: 0, // TODO: agregar al backend
        newCustomersMonth: json['newCustomersThisMonth'] ?? 0,
        averageOrderValue:
            json['totalInvoices'] > 0
                ? ((json['totalRevenue'] ?? 0).toDouble() /
                    json['totalInvoices'])
                : 0.0,
        todayGrowth: 0.0, // TODO: agregar al backend
      ),
      expenses: ExpenseStatsModel(
        totalAmount: (json['totalExpenses'] ?? 0).toDouble(),
        totalExpenses: 0, // TODO: agregar al backend
        monthlyExpenses: (json['totalExpenses'] ?? 0).toDouble(),
        todayExpenses: 0.0, // TODO: agregar al backend
        pendingExpenses: 0, // TODO: agregar al backend
        approvedExpenses: 0, // TODO: agregar al backend
        monthlyGrowth: 0.0, // TODO: agregar al backend
        expensesByCategory: _parseExpensesByCategory(
          json['expensesByCategory'],
        ),
      ),
      profitability:
          json['profitability'] != null
              ? ProfitabilityStatsModel.fromJson(json['profitability'])
              : _createDefaultProfitabilityStats(json),
      paymentMethodsBreakdown: _parsePaymentMethodsBreakdown(
        json['paymentMethodsBreakdown'],
      ),
      incomeTypeBreakdown: _parseIncomeTypeBreakdown(
        json['incomeTypeBreakdown'],
      ),
    );
  }

  Map<String, dynamic> toJson() {
    // Convertir a la estructura esperada por el backend
    return {
      'totalRevenue': sales.totalAmount,
      'totalExpenses': expenses.totalAmount,
      'netProfit': sales.totalAmount - expenses.totalAmount,
      'profitMargin':
          sales.totalAmount > 0
              ? ((sales.totalAmount - expenses.totalAmount) /
                  sales.totalAmount *
                  100)
              : 0.0,
      'totalInvoices': invoices.totalInvoices,
      'paidInvoices': invoices.paidInvoices,
      'pendingInvoices': invoices.pendingInvoices,
      'totalCustomers': customers.totalCustomers,
      'activeCustomers': customers.activeCustomers,
      'newCustomersThisMonth': customers.newCustomersMonth,
      'totalProducts': products.totalProducts,
      'lowStockProducts': products.lowStockProducts,
      'outOfStockProducts': products.outOfStockProducts,
      'profitability': (profitability as ProfitabilityStatsModel).toJson(),
    };
  }

  static ProfitabilityStatsModel _createDefaultProfitabilityStats(
    Map<String, dynamic> json,
  ) {
    final totalRevenue = (json['totalRevenue'] ?? 0).toDouble();
    final totalCOGS = 0.0; // TODO: Calcular COGS real cuando esté el backend
    final grossProfit = totalRevenue - totalCOGS;
    final grossMarginPercentage =
        totalRevenue > 0 ? (grossProfit / totalRevenue * 100) : 0.0;
    final totalExpenses = (json['totalExpenses'] ?? 0).toDouble();
    final netProfit = grossProfit - totalExpenses;
    final netMarginPercentage =
        totalRevenue > 0 ? (netProfit / totalRevenue * 100) : 0.0;

    return ProfitabilityStatsModel(
      totalRevenue: totalRevenue,
      totalCOGS: totalCOGS,
      grossProfit: grossProfit,
      grossMarginPercentage: grossMarginPercentage,
      netProfit: netProfit,
      netMarginPercentage: netMarginPercentage,
      averageMarginPerSale: grossMarginPercentage,
      topProfitableProducts: const [],
      lowProfitableProducts: const [],
      marginsByCategory: const {},
      trend: const ProfitabilityTrendModel(
        previousPeriodGrossMargin: 0.0,
        currentPeriodGrossMargin: 0.0,
        marginGrowth: 0.0,
        isImproving: false,
        dailyMargins: [],
      ),
    );
  }

  static Map<String, double> _parseExpensesByCategory(dynamic categoriesData) {
    if (categoriesData == null) return <String, double>{};

    if (categoriesData is Map<String, dynamic>) {
      return categoriesData.map(
        (key, value) => MapEntry(key, (value ?? 0).toDouble()),
      );
    } else if (categoriesData is List) {
      final Map<String, double> result = <String, double>{};
      for (final item in categoriesData) {
        if (item is Map<String, dynamic>) {
          final categoryName =
              item['categoryName'] ?? item['name'] ?? 'Sin categoría';
          final amount =
              (item['totalAmount'] ?? item['amount'] ?? 0).toDouble();
          result[categoryName] = amount;
        }
      }
      return result;
    }

    return <String, double>{};
  }

  // Helper method para convertir cualquier tipo a double de manera segura
  static double _toDouble(dynamic value) {
    if (value == null) return 0.0;
    if (value is double) return value;
    if (value is int) return value.toDouble();
    if (value is String) return double.tryParse(value) ?? 0.0;
    return 0.0;
  }

  static List<PaymentMethodStats> _parsePaymentMethodsBreakdown(
    dynamic paymentMethodsData,
  ) {
    if (paymentMethodsData == null) return <PaymentMethodStats>[];

    if (paymentMethodsData is List) {
      return paymentMethodsData.map((item) {
        if (item is Map<String, dynamic>) {
          return PaymentMethodStats(
            method: item['method'] ?? '',
            count: item['count'] ?? 0,
            totalAmount: _toDouble(item['totalAmount']),
            percentage: _toDouble(item['percentage']),
          );
        }
        return const PaymentMethodStats(
          method: '',
          count: 0,
          totalAmount: 0.0,
          percentage: 0.0,
        );
      }).toList();
    }

    return <PaymentMethodStats>[];
  }

  static IncomeTypeBreakdown _parseIncomeTypeBreakdown(
    dynamic incomeTypeData,
  ) {
    if (incomeTypeData == null) {
      return const IncomeTypeBreakdown(
        invoices: 0.0,
        credits: 0.0,
        total: 0.0,
      );
    }

    if (incomeTypeData is Map<String, dynamic>) {
      return IncomeTypeBreakdown(
        invoices: _toDouble(incomeTypeData['invoices']),
        credits: _toDouble(incomeTypeData['credits']),
        total: _toDouble(incomeTypeData['total']),
      );
    }

    return const IncomeTypeBreakdown(
      invoices: 0.0,
      credits: 0.0,
      total: 0.0,
    );
  }
}

class SalesStatsModel extends SalesStats {
  const SalesStatsModel({
    required super.totalAmount,
    required super.totalSales,
    required super.todaySales,
    required super.yesterdaySales,
    required super.monthlySales,
    required super.yearSales,
    required super.todayGrowth,
    required super.monthlyGrowth,
  });

  factory SalesStatsModel.fromJson(Map<String, dynamic> json) {
    return SalesStatsModel(
      totalAmount: (json['totalAmount'] ?? 0).toDouble(),
      totalSales: json['totalSales'] ?? 0,
      todaySales: (json['todaySales'] ?? 0).toDouble(),
      yesterdaySales: (json['yesterdaySales'] ?? 0).toDouble(),
      monthlySales: (json['monthlySales'] ?? 0).toDouble(),
      yearSales: (json['yearSales'] ?? 0).toDouble(),
      todayGrowth: (json['todayGrowth'] ?? 0).toDouble(),
      monthlyGrowth: (json['monthlyGrowth'] ?? 0).toDouble(),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'totalAmount': totalAmount,
      'totalSales': totalSales,
      'todaySales': todaySales,
      'yesterdaySales': yesterdaySales,
      'monthlySales': monthlySales,
      'yearSales': yearSales,
      'todayGrowth': todayGrowth,
      'monthlyGrowth': monthlyGrowth,
    };
  }
}

class InvoiceStatsModel extends InvoiceStats {
  const InvoiceStatsModel({
    required super.totalInvoices,
    required super.todayInvoices,
    required super.pendingInvoices,
    required super.paidInvoices,
    required super.averageInvoiceValue,
    required super.todayGrowth,
  });

  factory InvoiceStatsModel.fromJson(Map<String, dynamic> json) {
    return InvoiceStatsModel(
      totalInvoices: json['totalInvoices'] ?? 0,
      todayInvoices: json['todayInvoices'] ?? 0,
      pendingInvoices: json['pendingInvoices'] ?? 0,
      paidInvoices: json['paidInvoices'] ?? 0,
      averageInvoiceValue: (json['averageInvoiceValue'] ?? 0).toDouble(),
      todayGrowth: (json['todayGrowth'] ?? 0).toDouble(),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'totalInvoices': totalInvoices,
      'todayInvoices': todayInvoices,
      'pendingInvoices': pendingInvoices,
      'paidInvoices': paidInvoices,
      'averageInvoiceValue': averageInvoiceValue,
      'todayGrowth': todayGrowth,
    };
  }
}

class ProductStatsModel extends ProductStats {
  const ProductStatsModel({
    required super.totalProducts,
    required super.activeProducts,
    required super.lowStockProducts,
    required super.outOfStockProducts,
    required super.totalInventoryValue,
    required super.todayGrowth,
  });

  factory ProductStatsModel.fromJson(Map<String, dynamic> json) {
    return ProductStatsModel(
      totalProducts: json['totalProducts'] ?? 0,
      activeProducts: json['activeProducts'] ?? 0,
      lowStockProducts: json['lowStockProducts'] ?? 0,
      outOfStockProducts: json['outOfStockProducts'] ?? 0,
      totalInventoryValue: (json['totalInventoryValue'] ?? 0).toDouble(),
      todayGrowth: json['todayGrowth'] ?? 0,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'totalProducts': totalProducts,
      'activeProducts': activeProducts,
      'lowStockProducts': lowStockProducts,
      'outOfStockProducts': outOfStockProducts,
      'totalInventoryValue': totalInventoryValue,
      'todayGrowth': todayGrowth,
    };
  }
}

class CustomerStatsModel extends CustomerStats {
  const CustomerStatsModel({
    required super.totalCustomers,
    required super.activeCustomers,
    required super.newCustomersToday,
    required super.newCustomersMonth,
    required super.averageOrderValue,
    required super.todayGrowth,
  });

  factory CustomerStatsModel.fromJson(Map<String, dynamic> json) {
    return CustomerStatsModel(
      totalCustomers: json['totalCustomers'] ?? 0,
      activeCustomers: json['activeCustomers'] ?? 0,
      newCustomersToday: json['newCustomersToday'] ?? 0,
      newCustomersMonth: json['newCustomersMonth'] ?? 0,
      averageOrderValue: (json['averageOrderValue'] ?? 0).toDouble(),
      todayGrowth: (json['todayGrowth'] ?? 0).toDouble(),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'totalCustomers': totalCustomers,
      'activeCustomers': activeCustomers,
      'newCustomersToday': newCustomersToday,
      'newCustomersMonth': newCustomersMonth,
      'averageOrderValue': averageOrderValue,
      'todayGrowth': todayGrowth,
    };
  }
}

class ExpenseStatsModel extends ExpenseStats {
  const ExpenseStatsModel({
    required super.totalAmount,
    required super.totalExpenses,
    required super.monthlyExpenses,
    required super.todayExpenses,
    required super.pendingExpenses,
    required super.approvedExpenses,
    required super.monthlyGrowth,
    required super.expensesByCategory,
  });

  factory ExpenseStatsModel.fromJson(Map<String, dynamic> json) {
    return ExpenseStatsModel(
      totalAmount: (json['totalAmount'] ?? 0).toDouble(),
      totalExpenses: json['totalExpenses'] ?? 0,
      monthlyExpenses: (json['monthlyExpenses'] ?? 0).toDouble(),
      todayExpenses: (json['todayExpenses'] ?? 0).toDouble(),
      pendingExpenses: json['pendingExpenses'] ?? 0,
      approvedExpenses: json['approvedExpenses'] ?? 0,
      monthlyGrowth: (json['monthlyGrowth'] ?? 0).toDouble(),
      expensesByCategory: ExpenseStatsModel._parseExpensesByCategory(
        json['expensesByCategory'],
      ),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'totalAmount': totalAmount,
      'totalExpenses': totalExpenses,
      'monthlyExpenses': monthlyExpenses,
      'todayExpenses': todayExpenses,
      'pendingExpenses': pendingExpenses,
      'approvedExpenses': approvedExpenses,
      'monthlyGrowth': monthlyGrowth,
      'expensesByCategory': expensesByCategory,
    };
  }

  static Map<String, double> _parseExpensesByCategory(dynamic categoriesData) {
    if (categoriesData == null) return <String, double>{};

    if (categoriesData is Map<String, dynamic>) {
      return categoriesData.map(
        (key, value) => MapEntry(key, (value ?? 0).toDouble()),
      );
    } else if (categoriesData is List) {
      final Map<String, double> result = <String, double>{};
      for (final item in categoriesData) {
        if (item is Map<String, dynamic>) {
          final categoryName =
              item['categoryName'] ?? item['name'] ?? 'Sin categoría';
          final amount =
              (item['totalAmount'] ?? item['amount'] ?? 0).toDouble();
          result[categoryName] = amount;
        }
      }
      return result;
    }

    return <String, double>{};
  }
}
