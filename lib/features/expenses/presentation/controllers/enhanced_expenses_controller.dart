// lib/features/expenses/presentation/controllers/enhanced_expenses_controller.dart
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import '../../domain/repositories/expense_repository.dart';
import '../../domain/entities/expense.dart';
import '../../domain/entities/expense_stats.dart';
import '../../domain/usecases/get_expenses_usecase.dart';
import '../../domain/usecases/delete_expense_usecase.dart';
import '../../domain/usecases/get_expense_stats_usecase.dart';
import '../../domain/usecases/approve_expense_usecase.dart';
import '../../domain/usecases/submit_expense_usecase.dart';

class EnhancedExpensesController extends GetxController {
  // Dependencies
  final GetExpensesUseCase _getExpensesUseCase;
  final DeleteExpenseUseCase _deleteExpenseUseCase;
  final GetExpenseStatsUseCase _getExpenseStatsUseCase;
  final ApproveExpenseUseCase _approveExpenseUseCase;
  final SubmitExpenseUseCase _submitExpenseUseCase;

  EnhancedExpensesController({
    required GetExpensesUseCase getExpensesUseCase,
    required DeleteExpenseUseCase deleteExpenseUseCase,
    required GetExpenseStatsUseCase getExpenseStatsUseCase,
    required ApproveExpenseUseCase approveExpenseUseCase,
    required SubmitExpenseUseCase submitExpenseUseCase,
  }) : _getExpensesUseCase = getExpensesUseCase,
       _deleteExpenseUseCase = deleteExpenseUseCase,
       _getExpenseStatsUseCase = getExpenseStatsUseCase,
       _approveExpenseUseCase = approveExpenseUseCase,
       _submitExpenseUseCase = submitExpenseUseCase;

  // ==================== OBSERVABLES ====================

  // Estados de carga
  final _isLoading = false.obs;
  final _isLoadingMore = false.obs;
  final _isRefreshing = false.obs;
  final _isDeleting = false.obs;
  final _isApproving = false.obs;
  final _isSubmitting = false.obs;

  // Datos principales
  final _expenses = <Expense>[].obs;
  final Rxn<ExpenseStats> _stats = Rxn<ExpenseStats>();

  // Paginaci√≥n
  final _currentPage = 1.obs;
  final _totalPages = 1.obs;
  final _totalItems = 0.obs;
  final _hasNextPage = false.obs;

  // Filtros y b√∫squeda
  final _currentStatus = Rxn<ExpenseStatus>();
  final _currentType = Rxn<ExpenseType>();
  final _selectedCategoryId = Rxn<String>();
  final _searchTerm = ''.obs;
  final _sortBy = 'createdAt'.obs;
  final _sortOrder = 'DESC'.obs;
  final _startDate = Rxn<DateTime>();
  final _endDate = Rxn<DateTime>();
  
  // ‚úÖ NUEVO: Filtro por per√≠odo predefinido - Cambiado a 'all' por defecto
  final _currentPeriod = 'all'.obs; // today, week, month, all

  // UI Controllers
  final searchController = TextEditingController();
  final scrollController = ScrollController();

  // Configuraci√≥n
  static const int _pageSize = 20;

  // ==================== GETTERS ====================

  bool get isLoading => _isLoading.value;
  bool get isLoadingMore => _isLoadingMore.value;
  bool get isRefreshing => _isRefreshing.value;
  bool get isDeleting => _isDeleting.value;
  bool get isApproving => _isApproving.value;
  bool get isSubmitting => _isSubmitting.value;

  List<Expense> get expenses => _expenses;
  ExpenseStats? get stats => _stats.value;

  int get currentPage => _currentPage.value;
  int get totalPages => _totalPages.value;
  int get totalItems => _totalItems.value;
  bool get hasNextPage => _hasNextPage.value;
  bool get hasExpenses => _expenses.isNotEmpty;

  ExpenseStatus? get currentStatus => _currentStatus.value;
  ExpenseType? get currentType => _currentType.value;
  String? get selectedCategoryId => _selectedCategoryId.value;
  String get searchTerm => _searchTerm.value;
  String get sortBy => _sortBy.value;
  String get sortOrder => _sortOrder.value;
  DateTime? get startDate => _startDate.value;
  DateTime? get endDate => _endDate.value;
  String get currentPeriod => _currentPeriod.value;

  // ‚úÖ NUEVO: Getter para verificar si hay filtros activos
  bool get hasActiveFilters =>
      _currentStatus.value != null ||
      _currentType.value != null ||
      _selectedCategoryId.value != null ||
      _searchTerm.value.isNotEmpty ||
      _currentPeriod.value != 'all';

  @override
  void onInit() {
    super.onInit();
    print('üßÆ EnhancedExpensesController: Inicializando...');
    
    // ‚úÖ Configurar scroll infinito
    _setupScrollListener();
    
    // ‚úÖ Cargar datos iniciales autom√°ticamente
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _loadInitialData();
    });
  }

  @override
  void onClose() {
    print('üßÆ EnhancedExpensesController: Cerrando y limpiando recursos...');
    
    // ‚úÖ Limpiar controladores
    searchController.dispose();
    scrollController.dispose();
    
    super.onClose();
  }

  // ==================== CONFIGURACI√ìN INICIAL ====================

  void _setupScrollListener() {
    scrollController.addListener(() {
      if (scrollController.position.pixels >=
          scrollController.position.maxScrollExtent - 200) {
        if (!_isLoadingMore.value && _hasNextPage.value) {
          _loadMoreExpenses();
        }
      }
    });
  }

  Future<void> _loadInitialData() async {
    print('üßÆ Cargando datos iniciales...');
    
    // ‚úÖ Cargar en paralelo para mejor rendimiento
    await Future.wait([
      _loadExpenses(reset: true),
      _loadStats(),
    ]);
    
    print('‚úÖ Datos iniciales cargados correctamente');
  }

  // ==================== CARGA DE DATOS ====================

  Future<void> _loadExpenses({bool reset = false}) async {
    if (reset) {
      _isLoading.value = true;
      _currentPage.value = 1;
      _expenses.clear();
    } else {
      _isLoadingMore.value = true;
    }

    try {
      print('üîç Cargando gastos - P√°gina: ${_currentPage.value}');
      
      // ‚úÖ Calcular fechas seg√∫n el per√≠odo seleccionado
      final dateRange = _getDateRangeForPeriod(_currentPeriod.value);
      
      final result = await _getExpensesUseCase.call(
        GetExpensesParams(
          page: _currentPage.value,
          limit: _pageSize,
          search: _searchTerm.value.isEmpty ? null : _searchTerm.value,
          status: _currentStatus.value?.name,
          type: _currentType.value?.name,
          categoryId: _selectedCategoryId.value,
          startDate: dateRange['start'],
          endDate: dateRange['end'],
          orderBy: _sortBy.value,
          orderDirection: _sortOrder.value,
        ),
      );

      result.fold(
        (failure) {
          print('‚ùå Error cargando gastos: ${failure.message}');
          Get.snackbar(
            'Error',
            'No se pudieron cargar los gastos: ${failure.message}',
            snackPosition: SnackPosition.BOTTOM,
            backgroundColor: Colors.red.shade100,
            colorText: Colors.red.shade800,
          );
        },
        (response) {
          print('‚úÖ Gastos cargados: ${response.data.length} items');
          
          if (reset) {
            _expenses.assignAll(response.data);
          } else {
            _expenses.addAll(response.data);
          }
          
          // ‚úÖ Actualizar metadatos de paginaci√≥n
          _updatePaginationMetadata(response.meta);
        },
      );
    } catch (e) {
      print('üí• Error inesperado cargando gastos: $e');
      Get.snackbar(
        'Error',
        'Error inesperado al cargar gastos',
        snackPosition: SnackPosition.BOTTOM,
        backgroundColor: Colors.red.shade100,
        colorText: Colors.red.shade800,
      );
    } finally {
      _isLoading.value = false;
      _isLoadingMore.value = false;
      _isRefreshing.value = false;
    }
  }

  Future<void> _loadStats() async {
    try {
      print('üìä Cargando estad√≠sticas...');
      
      // ‚úÖ Calcular fechas seg√∫n el per√≠odo seleccionado para consistencia
      final dateRange = _getDateRangeForPeriod(_currentPeriod.value);
      
      // ‚úÖ Cargar estad√≠sticas con el mismo rango de fecha que la lista
      final result = await _getExpenseStatsUseCase.call(
        GetExpenseStatsParams(
          startDate: dateRange['start'],
          endDate: dateRange['end'],
        ),
      );

      result.fold(
        (failure) {
          print('‚ùå Error cargando estad√≠sticas: ${failure.message}');
        },
        (stats) {
          print('‚úÖ Estad√≠sticas cargadas correctamente');
          
          // ‚úÖ Enriquecer estad√≠sticas con datos calculados
          _stats.value = _enrichStatsWithCalculatedData(stats);
        },
      );
    } catch (e) {
      print('üí• Error inesperado cargando estad√≠sticas: $e');
    }
  }

  Future<void> _loadMoreExpenses() async {
    if (_isLoadingMore.value || !_hasNextPage.value) return;
    
    _currentPage.value++;
    await _loadExpenses();
  }

  // ==================== FILTROS Y B√öSQUEDA ====================

  void updateSearch(String term) {
    print('üîç Actualizando b√∫squeda: "$term"');
    _searchTerm.value = term;
    _debounceSearch();
  }

  Timer? _searchTimer;
  void _debounceSearch() {
    _searchTimer?.cancel();
    _searchTimer = Timer(const Duration(milliseconds: 500), () {
      _loadExpenses(reset: true);
    });
  }

  void setPeriodFilter(String period) {
    print('üìÖ Cambiando per√≠odo a: $period');
    _currentPeriod.value = period;
    _loadExpenses(reset: true);
    _loadStats(); // ‚úÖ Recargar estad√≠sticas con nuevo per√≠odo
  }

  void applyStatusFilter(ExpenseStatus? status) {
    print('üìã Aplicando filtro de estado: ${status?.displayName ?? "Todos"}');
    _currentStatus.value = status;
    _loadExpenses(reset: true);
  }

  void applyTypeFilter(ExpenseType? type) {
    print('üè∑Ô∏è Aplicando filtro de tipo: ${type?.displayName ?? "Todos"}');
    _currentType.value = type;
    _loadExpenses(reset: true);
  }

  void applyCategoryFilter(String? categoryId) {
    print('üìÇ Aplicando filtro de categor√≠a: $categoryId');
    _selectedCategoryId.value = categoryId;
    _loadExpenses(reset: true);
  }

  void applyDateFilter(DateTime? start, DateTime? end) {
    print('üìÖ Aplicando filtro de fecha: $start - $end');
    _startDate.value = start;
    _endDate.value = end;
    _currentPeriod.value = 'custom'; // ‚úÖ Cambiar a per√≠odo personalizado
    _loadExpenses(reset: true);
  }

  void changeSorting(String sortBy, String sortOrder) {
    print('üîÑ Cambiando ordenamiento: $sortBy $sortOrder');
    _sortBy.value = sortBy;
    _sortOrder.value = sortOrder;
    _loadExpenses(reset: true);
  }

  void clearFilters() {
    print('üßπ Limpiando todos los filtros...');
    
    _currentStatus.value = null;
    _currentType.value = null;
    _selectedCategoryId.value = null;
    _startDate.value = null;
    _endDate.value = null;
    _currentPeriod.value = 'all';
    
    searchController.clear();
    _searchTerm.value = '';
    
    _loadExpenses(reset: true);
    _loadStats();
  }

  // ==================== ACCIONES DE GASTOS ====================

  Future<void> refreshExpenses() async {
    print('üîÑ Refrescando gastos...');
    _isRefreshing.value = true;
    await _loadInitialData();
  }

  void showExpenseDetails(String expenseId) {
    print('üëÄ Mostrando detalles del gasto: $expenseId');
    Get.toNamed('/expenses/$expenseId');
  }

  void goToCreateExpense() {
    print('‚ûï Navegando a crear gasto...');
    Get.toNamed('/expenses/create');
  }

  void goToEditExpense(String expenseId) {
    print('‚úèÔ∏è Navegando a editar gasto: $expenseId');
    Get.toNamed('/expenses/$expenseId/edit');
  }

  void goToExpenseAnalytics() {
    print('üìä Navegando a an√°lisis de gastos...');
    Get.toNamed('/expenses/analytics');
  }

  Future<void> confirmDelete(Expense expense) async {
    final confirmed = await Get.dialog<bool>(
      AlertDialog(
        title: const Text('Confirmar Eliminaci√≥n'),
        content: Text('¬øEst√°s seguro de que quieres eliminar el gasto "${expense.description}"?'),
        actions: [
          TextButton(
            onPressed: () => Get.back(result: false),
            child: const Text('Cancelar'),
          ),
          TextButton(
            onPressed: () => Get.back(result: true),
            style: TextButton.styleFrom(foregroundColor: Colors.red),
            child: const Text('Eliminar'),
          ),
        ],
      ),
    );

    if (confirmed == true) {
      await _deleteExpense(expense.id);
    }
  }

  Future<void> _deleteExpense(String expenseId) async {
    _isDeleting.value = true;
    
    try {
      print('üóëÔ∏è Eliminando gasto: $expenseId');
      
      final result = await _deleteExpenseUseCase.call(
        DeleteExpenseParams(id: expenseId),
      );
      
      result.fold(
        (failure) {
          print('‚ùå Error eliminando gasto: ${failure.message}');
          Get.snackbar(
            'Error',
            'No se pudo eliminar el gasto: ${failure.message}',
            snackPosition: SnackPosition.BOTTOM,
            backgroundColor: Colors.red.shade100,
            colorText: Colors.red.shade800,
          );
        },
        (_) {
          print('‚úÖ Gasto eliminado correctamente');
          
          // ‚úÖ Remover de la lista local
          _expenses.removeWhere((expense) => expense.id == expenseId);
          _totalItems.value--;
          
          // ‚úÖ Recargar estad√≠sticas
          _loadStats();
          
          Get.snackbar(
            '√âxito',
            'Gasto eliminado correctamente',
            snackPosition: SnackPosition.BOTTOM,
            backgroundColor: Colors.green.shade100,
            colorText: Colors.green.shade800,
          );
        },
      );
    } catch (e) {
      print('üí• Error inesperado eliminando gasto: $e');
      Get.snackbar(
        'Error',
        'Error inesperado al eliminar el gasto',
        snackPosition: SnackPosition.BOTTOM,
        backgroundColor: Colors.red.shade100,
        colorText: Colors.red.shade800,
      );
    } finally {
      _isDeleting.value = false;
    }
  }

  Future<void> confirmApprove(Expense expense) async {
    final confirmed = await Get.dialog<bool>(
      AlertDialog(
        title: const Text('Confirmar Aprobaci√≥n'),
        content: Text('¬øAprobar el gasto "${expense.description}" por ${expense.formattedAmount}?'),
        actions: [
          TextButton(
            onPressed: () => Get.back(result: false),
            child: const Text('Cancelar'),
          ),
          TextButton(
            onPressed: () => Get.back(result: true),
            style: TextButton.styleFrom(foregroundColor: Colors.green),
            child: const Text('Aprobar'),
          ),
        ],
      ),
    );

    if (confirmed == true) {
      await _approveExpense(expense.id);
    }
  }

  Future<void> _approveExpense(String expenseId) async {
    _isApproving.value = true;
    
    try {
      print('‚úÖ Aprobando gasto: $expenseId');
      
      final result = await _approveExpenseUseCase.call(
        ApproveExpenseParams(id: expenseId),
      );
      
      result.fold(
        (failure) {
          print('‚ùå Error aprobando gasto: ${failure.message}');
          Get.snackbar(
            'Error',
            'No se pudo aprobar el gasto: ${failure.message}',
            snackPosition: SnackPosition.BOTTOM,
            backgroundColor: Colors.red.shade100,
            colorText: Colors.red.shade800,
          );
        },
        (updatedExpense) {
          print('‚úÖ Gasto aprobado correctamente');
          
          // ‚úÖ Actualizar en la lista local
          final index = _expenses.indexWhere((expense) => expense.id == expenseId);
          if (index != -1) {
            _expenses[index] = updatedExpense;
          }
          
          // ‚úÖ Recargar estad√≠sticas
          _loadStats();
          
          Get.snackbar(
            '√âxito',
            'Gasto aprobado correctamente',
            snackPosition: SnackPosition.BOTTOM,
            backgroundColor: Colors.green.shade100,
            colorText: Colors.green.shade800,
          );
        },
      );
    } catch (e) {
      print('üí• Error inesperado aprobando gasto: $e');
      Get.snackbar(
        'Error',
        'Error inesperado al aprobar el gasto',
        snackPosition: SnackPosition.BOTTOM,
        backgroundColor: Colors.red.shade100,
        colorText: Colors.red.shade800,
      );
    } finally {
      _isApproving.value = false;
    }
  }

  Future<void> submitExpense(String expenseId) async {
    _isSubmitting.value = true;
    
    try {
      print('üì§ Enviando gasto para aprobaci√≥n: $expenseId');
      
      final result = await _submitExpenseUseCase.call(
        SubmitExpenseParams(id: expenseId),
      );
      
      result.fold(
        (failure) {
          print('‚ùå Error enviando gasto: ${failure.message}');
          Get.snackbar(
            'Error',
            'No se pudo enviar el gasto: ${failure.message}',
            snackPosition: SnackPosition.BOTTOM,
            backgroundColor: Colors.red.shade100,
            colorText: Colors.red.shade800,
          );
        },
        (updatedExpense) {
          print('‚úÖ Gasto enviado correctamente');
          
          // ‚úÖ Actualizar en la lista local
          final index = _expenses.indexWhere((expense) => expense.id == expenseId);
          if (index != -1) {
            _expenses[index] = updatedExpense;
          }
          
          // ‚úÖ Recargar estad√≠sticas
          _loadStats();
          
          Get.snackbar(
            '√âxito',
            'Gasto enviado para aprobaci√≥n',
            snackPosition: SnackPosition.BOTTOM,
            backgroundColor: Colors.blue.shade100,
            colorText: Colors.blue.shade800,
          );
        },
      );
    } catch (e) {
      print('üí• Error inesperado enviando gasto: $e');
      Get.snackbar(
        'Error',
        'Error inesperado al enviar el gasto',
        snackPosition: SnackPosition.BOTTOM,
        backgroundColor: Colors.red.shade100,
        colorText: Colors.red.shade800,
      );
    } finally {
      _isSubmitting.value = false;
    }
  }

  // ==================== EXPORTACI√ìN ====================

  Future<void> exportToPdf() async {
    print('üìÑ Exportando a PDF...');
    // ‚úÖ Implementar exportaci√≥n a PDF
    Get.snackbar(
      'Pr√≥ximamente',
      'La exportaci√≥n a PDF estar√° disponible pronto',
      snackPosition: SnackPosition.BOTTOM,
    );
  }

  Future<void> exportToExcel() async {
    print('üìä Exportando a Excel...');
    // ‚úÖ Implementar exportaci√≥n a Excel
    Get.snackbar(
      'Pr√≥ximamente',
      'La exportaci√≥n a Excel estar√° disponible pronto',
      snackPosition: SnackPosition.BOTTOM,
    );
  }

  Future<void> shareExpensesSummary() async {
    print('üì§ Compartiendo resumen...');
    // ‚úÖ Implementar compartir resumen
    Get.snackbar(
      'Pr√≥ximamente',
      'Compartir resumen estar√° disponible pronto',
      snackPosition: SnackPosition.BOTTOM,
    );
  }

  // ==================== M√âTODOS AUXILIARES ====================

  void _updatePaginationMetadata(PaginationMeta meta) {
    _totalPages.value = meta.totalPages;
    _totalItems.value = meta.total;
    _hasNextPage.value = meta.hasNext;
    
    print('üìÑ Paginaci√≥n actualizada: ${meta.page}/${meta.totalPages} (${meta.total} total)');
  }

  Map<String, DateTime?> _getDateRangeForPeriod(String period) {
    final now = DateTime.now();
    
    switch (period) {
      case 'today':
        final today = DateTime(now.year, now.month, now.day);
        return {
          'start': today,
          'end': today.add(const Duration(days: 1)),
        };
        
      case 'week':
        final startOfWeek = now.subtract(Duration(days: now.weekday - 1));
        final start = DateTime(startOfWeek.year, startOfWeek.month, startOfWeek.day);
        return {
          'start': start,
          'end': start.add(const Duration(days: 7)),
        };
        
      case 'month':
        final startOfMonth = DateTime(now.year, now.month, 1);
        final endOfMonth = DateTime(now.year, now.month + 1, 1);
        return {
          'start': startOfMonth,
          'end': endOfMonth,
        };
        
      case 'custom':
        return {
          'start': _startDate.value,
          'end': _endDate.value,
        };
        
      default: // 'all'
        return {
          'start': null,
          'end': null,
        };
    }
  }

  ExpenseStats _enrichStatsWithCalculatedData(ExpenseStats originalStats) {
    final now = DateTime.now();
    
    // ‚úÖ Calcular datos adicionales usando los gastos cargados
    final dailyCount = _calculateDailyCount();
    final weeklyCount = _calculateWeeklyCount();
    final monthlyCount = _calculateMonthlyCount();
    final dailyAmount = _calculateDailyAmount();
    final weeklyAmount = _calculateWeeklyAmount();
    final monthlyAmount = _calculateMonthlyAmount();
    final previousMonthAmount = _calculatePreviousMonthAmount();
    
    return ExpenseStats(
      totalExpenses: originalStats.totalExpenses,
      totalAmount: originalStats.totalAmount,
      monthlyAmount: monthlyAmount, // ‚úÖ Usar valor calculado localmente
      weeklyAmount: weeklyAmount,   // ‚úÖ Usar valor calculado localmente
      dailyAmount: dailyAmount,     // ‚úÖ Usar valor calculado localmente
      pendingExpenses: originalStats.pendingExpenses,
      pendingAmount: originalStats.pendingAmount,
      approvedExpenses: originalStats.approvedExpenses,
      approvedAmount: originalStats.approvedAmount,
      paidExpenses: originalStats.paidExpenses,
      paidAmount: originalStats.paidAmount,
      rejectedExpenses: originalStats.rejectedExpenses,
      rejectedAmount: originalStats.rejectedAmount,
      averageExpenseAmount: originalStats.averageExpenseAmount,
      expensesByCategory: originalStats.expensesByCategory,
      expensesByType: originalStats.expensesByType,
      expensesByStatus: originalStats.expensesByStatus,
      monthlyTrends: originalStats.monthlyTrends,
      dailyCount: dailyCount,
      weeklyCount: weeklyCount,
      monthlyCount: monthlyCount,
      previousMonthAmount: previousMonthAmount,
    );
  }

  int _calculateDailyCount() {
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    
    return _expenses.where((expense) {
      final expenseDate = DateTime(
        expense.date.year,
        expense.date.month,
        expense.date.day,
      );
      return expenseDate.isAtSameMomentAs(today);
    }).length;
  }

  int _calculateWeeklyCount() {
    final now = DateTime.now();
    final startOfWeek = now.subtract(Duration(days: now.weekday - 1));
    final start = DateTime(startOfWeek.year, startOfWeek.month, startOfWeek.day);
    final end = start.add(const Duration(days: 7));
    
    return _expenses.where((expense) {
      final expenseDate = DateTime(expense.date.year, expense.date.month, expense.date.day);
      return (expenseDate.isAtSameMomentAs(start) || expenseDate.isAfter(start)) && 
             expenseDate.isBefore(end);
    }).length;
  }

  int _calculateMonthlyCount() {
    final now = DateTime.now();
    final startOfMonth = DateTime(now.year, now.month, 1);
    final endOfMonth = DateTime(now.year, now.month + 1, 1);
    
    return _expenses.where((expense) {
      final expenseDate = DateTime(expense.date.year, expense.date.month, expense.date.day);
      return (expenseDate.isAtSameMomentAs(startOfMonth) || expenseDate.isAfter(startOfMonth)) && 
             expenseDate.isBefore(endOfMonth);
    }).length;
  }

  double _calculateDailyAmount() {
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    
    return _expenses.where((expense) {
      final expenseDate = DateTime(
        expense.date.year,
        expense.date.month,
        expense.date.day,
      );
      return expenseDate.isAtSameMomentAs(today);
    }).fold(0.0, (sum, expense) => sum + expense.amount);
  }

  double _calculateWeeklyAmount() {
    final now = DateTime.now();
    final startOfWeek = now.subtract(Duration(days: now.weekday - 1));
    final start = DateTime(startOfWeek.year, startOfWeek.month, startOfWeek.day);
    final end = start.add(const Duration(days: 7));
    
    return _expenses.where((expense) {
      final expenseDate = DateTime(expense.date.year, expense.date.month, expense.date.day);
      return (expenseDate.isAtSameMomentAs(start) || expenseDate.isAfter(start)) && 
             expenseDate.isBefore(end);
    }).fold(0.0, (sum, expense) => sum + expense.amount);
  }

  double _calculateMonthlyAmount() {
    final now = DateTime.now();
    final startOfMonth = DateTime(now.year, now.month, 1);
    final endOfMonth = DateTime(now.year, now.month + 1, 1);
    
    return _expenses.where((expense) {
      final expenseDate = DateTime(expense.date.year, expense.date.month, expense.date.day);
      return (expenseDate.isAtSameMomentAs(startOfMonth) || expenseDate.isAfter(startOfMonth)) && 
             expenseDate.isBefore(endOfMonth);
    }).fold(0.0, (sum, expense) => sum + expense.amount);
  }

  double _calculatePreviousMonthAmount() {
    final now = DateTime.now();
    final startOfPreviousMonth = DateTime(now.year, now.month - 1, 1);
    final endOfPreviousMonth = DateTime(now.year, now.month, 1);
    
    return _expenses.where((expense) {
      final expenseDate = DateTime(expense.date.year, expense.date.month, expense.date.day);
      return (expenseDate.isAtSameMomentAs(startOfPreviousMonth) || expenseDate.isAfter(startOfPreviousMonth)) && 
             expenseDate.isBefore(endOfPreviousMonth);
    }).fold(0.0, (sum, expense) => sum + expense.amount);
  }
}